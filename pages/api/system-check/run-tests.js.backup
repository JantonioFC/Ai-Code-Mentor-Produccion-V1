/**
 * ENDPOINT CR√çTICO DE SEGURIDAD - MISI√ìN 188.1
 * 
 * API endpoint para ejecutar suite de pruebas E2E
 * POST /api/system-check/run-tests
 * 
 * ‚ö†Ô∏è  ADVERTENCIA DE SEGURIDAD CR√çTICA:
 * Este endpoint ejecuta procesos del sistema. Implementaci√≥n con
 * medidas de seguridad extremas para prevenir inyecci√≥n de comandos.
 * 
 * DIRECTIVA: Integridad funcional y estabilidad de rama main
 * PRINCIPIO: Falla R√°pido - Verificar antes de Actuar
 */

import { spawn } from 'child_process';
import path from 'path';
import fs from 'fs';

// CONFIGURACI√ìN DE SEGURIDAD CR√çTICA
const SECURITY_CONFIG = {
  // Timeout m√°ximo de ejecuci√≥n optimizado - MISI√ìN 188.3.6
  MAX_EXECUTION_TIME: 45 * 1000, // 45 segundos (reducido de 5 minutos)
  
  // Lista blanca de comandos permitidos (√öNICO COMANDO PERMITIDO)
  // MISI√ìN 188.3.6: Configuraci√≥n optimizada para tests r√°pidos
  ALLOWED_COMMANDS: {
    'playwright-test': {
      args: ['test', '--reporter=json', '--timeout=15000', 'e2e/minimal-test.spec.js'],
      description: 'Ejecutar suite E2E optimizada (solo tests r√°pidos)'
    }
  },
  
  // Rate limiting simple (en memoria - mejorar en producci√≥n)
  RATE_LIMIT: {
    windowMs: 2 * 60 * 1000, // 2 minutos
    maxRequests: 1 // Solo 1 ejecuci√≥n cada 2 minutos
  }
};

// Rate limiting en memoria (MEJORAR CON REDIS EN PRODUCCI√ìN)
const executionTracker = new Map();

/**
 * VALIDADOR DE SEGURIDAD CR√çTICO
 * Valida que la solicitud es leg√≠tima y segura
 */
function validateSecurityConstraints(req) {
  const errors = [];
  
  // 1. Validar m√©todo HTTP
  if (req.method !== 'POST') {
    errors.push('M√©todo HTTP no permitido. Solo POST.');
  }
  
  // 2. Validar Content-Type (aunque sea opcional en este caso)
  const contentType = req.headers['content-type'];
  if (contentType && !contentType.includes('application/json')) {
    errors.push('Content-Type debe ser application/json');
  }
  
  // 3. Validar comando solicitado
  const { command } = req.body || {};
  if (!command || !SECURITY_CONFIG.ALLOWED_COMMANDS[command]) {
    errors.push(`Comando no permitido. Comandos v√°lidos: ${Object.keys(SECURITY_CONFIG.ALLOWED_COMMANDS).join(', ')}`);
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
}

/**
 * RATE LIMITER SIMPLE
 * Previene spam y DOS attacks
 */
function checkRateLimit(clientId) {
  const now = Date.now();
  const windowStart = now - SECURITY_CONFIG.RATE_LIMIT.windowMs;
  
  // Limpiar entradas expiradas
  for (const [id, timestamps] of executionTracker.entries()) {
    const validTimestamps = timestamps.filter(t => t > windowStart);
    if (validTimestamps.length === 0) {
      executionTracker.delete(id);
    } else {
      executionTracker.set(id, validTimestamps);
    }
  }
  
  // Verificar l√≠mite actual
  const clientExecutions = executionTracker.get(clientId) || [];
  const recentExecutions = clientExecutions.filter(t => t > windowStart);
  
  if (recentExecutions.length >= SECURITY_CONFIG.RATE_LIMIT.maxRequests) {
    return {
      allowed: false,
      resetTime: Math.ceil((recentExecutions[0] + SECURITY_CONFIG.RATE_LIMIT.windowMs - now) / 1000)
    };
  }
  
  // Registrar nueva ejecuci√≥n
  recentExecutions.push(now);
  executionTracker.set(clientId, recentExecutions);
  
  return { allowed: true };
}

/**
 * EJECUTOR DE PROCESO SEGURO CON RUTA DIRECTA - MISI√ìN 188.3
 * Ejecuta Playwright con ruta directa, eliminando dependencia de npx global
 * Soluci√≥n robusta para Error ENOENT spawn npx
 */
function executeSecureCommand(commandKey) {
  return new Promise((resolve, reject) => {
    const command = SECURITY_CONFIG.ALLOWED_COMMANDS[commandKey];
    if (!command) {
      reject(new Error('Comando no encontrado en lista blanca'));
      return;
    }
    
    // LOCALIZACI√ìN ROBUSTA DE PLAYWRIGHT LOCAL
    let executablePath, executableArgs;
    
    try {
      const playwrightPath = getPlaywrightExecutablePath();
      
      // Siempre usar Node.js wrapper para m√°xima compatibilidad
      executablePath = process.execPath; // ruta a node.exe/node
      executableArgs = [playwrightPath.scriptPath, ...command.args];
      
      console.log(`üîê [SECURITY] Ejecutando comando seguro via Node.js: ${executablePath} ${executableArgs.join(' ')}`);
      
    } catch (error) {
      console.error('‚ùå [SECURITY] Error localizando Playwright:', error.message);
      reject(error);
      return;
    }
    
    // SPAWN SEGURO: args separados previene inyecci√≥n de comandos
    const childProcess = spawn(executablePath, executableArgs, {
      cwd: process.cwd(), // Directorio actual del proyecto
      stdio: ['ignore', 'pipe', 'pipe'], // stdin ignorado, stdout/stderr capturados
      env: {
        ...process.env,
        NODE_ENV: 'test' // Forzar env de test
      },
      // PROTECCIONES ADICIONALES
      detached: false,  // No crear grupo de procesos separado
      shell: false      // CR√çTICO: No usar shell para prevenir inyecci√≥n
    });
    
    let stdout = '';
    let stderr = '';
    let isResolved = false;
    
    // Timeout de seguridad OBLIGATORIO
    const timeout = setTimeout(() => {
      if (!isResolved) {
        console.log('‚ö†Ô∏è  [SECURITY] Timeout - terminando proceso (optimizado a 45s)');
        childProcess.kill('SIGKILL'); // Terminaci√≥n forzada
        isResolved = true;
        reject(new Error(`Timeout de ejecuci√≥n optimizado (${SECURITY_CONFIG.MAX_EXECUTION_TIME}ms)`));
      }
    }, SECURITY_CONFIG.MAX_EXECUTION_TIME);
    
    // Capturar output
    childProcess.stdout.on('data', (data) => {
      stdout += data.toString();
    });
    
    childProcess.stderr.on('data', (data) => {
      stderr += data.toString();
    });
    
    // Manejo de finalizaci√≥n
    childProcess.on('close', (code, signal) => {
      if (!isResolved) {
        clearTimeout(timeout);
        isResolved = true;
        
        console.log(`‚úÖ [SECURITY] Proceso terminado - C√≥digo: ${code}, Signal: ${signal}`);
        
        if (signal === 'SIGKILL') {
          reject(new Error('Proceso terminado por timeout'));
        } else {
          resolve({
            code,
            signal,
            stdout,
            stderr,
            success: code === 0
          });
        }
      }
    });
    
    childProcess.on('error', (error) => {
      if (!isResolved) {
        clearTimeout(timeout);
        isResolved = true;
        
        // MANEJO ESPEC√çFICO DE ERROR ENOENT - MISI√ìN 188.3
        if (error.code === 'ENOENT') {
          console.error('‚ùå [SECURITY] Error ENOENT - Ejecutable no encontrado:', executablePath);
          const diagnostic = `Playwright no encontrado en ruta: ${executablePath}. Ejecute: npm install @playwright/test`;
          reject(new Error(`Ejecutable no encontrado: ${executablePath}. ${diagnostic}`));
        } else {
          console.error('‚ùå [SECURITY] Error ejecutando proceso:', error);
          reject(error);
        }
      }
    });
  });
}

/**
 * DETECCI√ìN ROBUSTA DE PLAYWRIGHT LOCAL - MISI√ìN 188.3.1
 * CORRECCI√ìN: Usa Node.js directo con CLI script para m√°xima compatibilidad
 * Elimina problema de spawn con archivos .cmd en Windows
 */
function getPlaywrightExecutablePath() {
  const projectRoot = process.cwd();
  
  // Verificar que el script CLI de Playwright existe
  const playwrightCliPath = path.join(projectRoot, 'node_modules', '@playwright', 'test', 'cli.js');
  
  if (fs.existsSync(playwrightCliPath)) {
    console.log(`‚úÖ [ROBUST-EXEC] Playwright CLI encontrado: ${playwrightCliPath}`);
    return {
      useNode: true,
      scriptPath: playwrightCliPath
    };
  }
  
  // Verificar instalaci√≥n alternativa (playwright-core)
  const playwrightCorePath = path.join(projectRoot, 'node_modules', 'playwright-core', 'cli.js');
  if (fs.existsSync(playwrightCorePath)) {
    console.log(`‚úÖ [ROBUST-EXEC] Playwright Core encontrado: ${playwrightCorePath}`);
    return {
      useNode: true,
      scriptPath: playwrightCorePath
    };
  }
  
  console.error(`‚ùå [ROBUST-EXEC] Playwright no encontrado en: ${playwrightCliPath}`);
  throw new Error(`Playwright no instalado localmente. Ejecute: npm install @playwright/test`);
}

// MISI√ìN 188.3: Funciones obsoletas eliminadas
// commandExists() y generateDiagnosticInfo() ya no necesarias
// La nueva implementaci√≥n usa rutas directas, eliminando dependencia de PATH

/**
 * PARSER SEGURO DE RESULTADOS PLAYWRIGHT - MISI√ìN 188.3.2
 * Procesa el output JSON de Playwright de forma defensiva
 * CORRECCI√ìN: Maneja caso cuando no hay tests configurados
 */
function parsePlaywrightResults(stdout, stderr, exitCode) {
  try {
    // CASO ESPECIAL: No hay tests configurados (c√≥digo de salida 1)
    if (exitCode === 1 && (stdout.includes('no tests found') || stdout.includes('No tests found') || stdout.trim() === '')) {
      console.log('‚ö†Ô∏è  [PLAYWRIGHT] No se encontraron tests configurados');
      return {
        summary: {
          stats: {
            total: 0,
            passed: 0,
            failed: 0,
            skipped: 0,
            duration: 0
          },
          success: true, // No es un fallo real, solo no hay tests
          timestamp: new Date().toISOString(),
          message: 'No se encontraron tests configurados en el proyecto'
        },
        failures: [],
        rawOutput: {
          stdout: stdout.length > 500 ? stdout.substring(0, 500) + '...' : stdout,
          stderr: stderr.length > 500 ? stderr.substring(0, 500) + '...' : stderr
        }
      };
    }
    
    // Playwright JSON reporter produce una l√≠nea JSON al final
    const lines = stdout.split('\n').filter(line => line.trim());
    
    // Buscar la l√≠nea que contiene el JSON de resultados
    let jsonResult = null;
    for (const line of lines) {
      try {
        const parsed = JSON.parse(line);
        if (parsed.stats || parsed.suites || parsed.tests) {
          jsonResult = parsed;
          break;
        }
      } catch {
        // L√≠nea no es JSON v√°lido, continuar
        continue;
      }
    }
    
    if (!jsonResult) {
      // Si no hay JSON, puede ser que Playwright no haya ejecutado tests
      console.log('‚ö†Ô∏è  [PLAYWRIGHT] No se encontr√≥ JSON de resultados, usando output como diagn√≥stico');
      return {
        summary: {
          stats: { total: 0, passed: 0, failed: 0, skipped: 0, duration: 0 },
          success: exitCode === 0,
          timestamp: new Date().toISOString(),
          message: exitCode === 0 ? 'Ejecuci√≥n completada sin JSON' : 'Error en ejecuci√≥n de tests',
          exitCode
        },
        failures: [],
        rawOutput: {
          stdout: stdout.length > 1000 ? stdout.substring(0, 1000) + '...' : stdout,
          stderr: stderr.length > 500 ? stderr.substring(0, 500) + '...' : stderr
        }
      };
    }
    
    // Extraer datos esenciales de forma defensiva
    const summary = {
      stats: {
        total: jsonResult.stats?.expected || 0,
        passed: jsonResult.stats?.passed || 0,
        failed: jsonResult.stats?.failed || 0,
        skipped: jsonResult.stats?.skipped || 0,
        duration: jsonResult.stats?.duration || 0
      },
      success: (jsonResult.stats?.failed || 0) === 0,
      timestamp: new Date().toISOString()
    };
    
    // Extraer detalles de tests fallidos (solo informaci√≥n esencial)
    const failures = [];
    if (jsonResult.suites && Array.isArray(jsonResult.suites)) {
      for (const suite of jsonResult.suites) {
        if (suite.specs && Array.isArray(suite.specs)) {
          for (const spec of suite.specs) {
            if (spec.tests && Array.isArray(spec.tests)) {
              for (const test of spec.tests) {
                if (test.outcome === 'unexpected') {
                  failures.push({
                    title: test.title || 'Test sin t√≠tulo',
                    file: spec.title || 'Archivo desconocido',
                    error: test.results?.[0]?.error?.message || 'Error desconocido'
                  });
                }
              }
            }
          }
        }
      }
    }
    
    return {
      summary,
      failures,
      rawOutput: {
        stdout: stdout.length > 1000 ? stdout.substring(0, 1000) + '...' : stdout,
        stderr: stderr.length > 500 ? stderr.substring(0, 500) + '...' : stderr
      }
    };
    
  } catch (error) {
    console.error('Error parseando resultados Playwright:', error);
    return {
      summary: {
        stats: { total: 0, passed: 0, failed: 0, skipped: 0, duration: 0 },
        success: false,
        timestamp: new Date().toISOString(),
        parseError: error.message,
        exitCode
      },
      failures: [],
      rawOutput: { stdout, stderr }
    };
  }
}

/**
 * HANDLER PRINCIPAL DEL ENDPOINT
 */
export default async function handler(req, res) {
  const startTime = Date.now();
  const clientId = req.headers['x-forwarded-for'] || req.connection.remoteAddress || 'unknown';
  
  console.log(`üö® [SECURITY AUDIT] Solicitud de ejecuci√≥n de pruebas - Cliente: ${clientId}`);
  
  try {
    // PASO 1: VALIDACI√ìN DE SEGURIDAD CR√çTICA
    const securityValidation = validateSecurityConstraints(req);
    if (!securityValidation.isValid) {
      console.log(`‚ùå [SECURITY] Validaci√≥n fallida: ${securityValidation.errors.join(', ')}`);
      return res.status(400).json({
        success: false,
        error: 'Validaci√≥n de seguridad fallida',
        details: securityValidation.errors
      });
    }
    
    // PASO 2: RATE LIMITING
    const rateLimitCheck = checkRateLimit(clientId);
    if (!rateLimitCheck.allowed) {
      console.log(`‚ö†Ô∏è  [SECURITY] Rate limit excedido - Cliente: ${clientId}`);
      return res.status(429).json({
        success: false,
        error: 'Demasiadas solicitudes',
        message: `Intenta nuevamente en ${rateLimitCheck.resetTime} segundos`,
        retryAfter: rateLimitCheck.resetTime
      });
    }
    
    // PASO 3: VALIDACI√ìN DE ENTORNO EXTENDIDA
    console.log('üìã [ENV] Validando entorno de ejecuci√≥n...');
    
    // Verificar que estamos en directorio correcto y que Playwright existe
    const projectRoot = process.cwd();
    const playwrightConfigExists = fs.existsSync(path.join(projectRoot, 'playwright.config.js'));
    
    if (!playwrightConfigExists) {
      console.log('‚ùå [SECURITY] Configuraci√≥n de Playwright no encontrada');
      return res.status(500).json({
        success: false,
        error: 'Sistema de pruebas no configurado correctamente',
        details: [
          'playwright.config.js no encontrado',
          'Ejecute: npx playwright install',
          `Directorio actual: ${projectRoot}`
        ]
      });
    }
    
    // MISI√ìN 188.3.1: Validaci√≥n robusta de Playwright local
    try {
      const playwrightPath = getPlaywrightExecutablePath();
      const pathInfo = `node ${playwrightPath.scriptPath}`;
      console.log(`‚úÖ [ENV] Playwright local validado: ${pathInfo}`);
    } catch (error) {
      console.log(`‚ùå [ENV] Playwright no disponible: ${error.message}`);
      return res.status(500).json({
        success: false,
        error: 'Sistema de pruebas no configurado correctamente',
        details: [
          error.message,
          'Ejecute: npm install',
          'Luego: npx playwright install',
          `Directorio: ${projectRoot}`
        ]
      });
    }
    
    // PASO 4: EJECUCI√ìN SEGURA DEL COMANDO
    console.log('üé≠ [EXEC] Iniciando ejecuci√≥n segura de Playwright...');
    
    const { command } = req.body;
    const execution = await executeSecureCommand(command);
    
    // PASO 5: PROCESAMIENTO SEGURO DE RESULTADOS
    const results = parsePlaywrightResults(execution.stdout, execution.stderr, execution.code);
    
    const executionTime = Date.now() - startTime;
    console.log(`‚úÖ [SECURITY AUDIT] Ejecuci√≥n completada - Duraci√≥n: ${executionTime}ms`);
    
    // RESPUESTA FINAL
    return res.status(200).json({
      success: true,
      execution: {
        command: SECURITY_CONFIG.ALLOWED_COMMANDS[command].description,
        exitCode: execution.code,
        executionTime,
        timestamp: new Date().toISOString()
      },
      testResults: results.summary,
      failures: results.failures,
      // rawOutput solo en desarrollo (comentar en producci√≥n)
      ...(process.env.NODE_ENV === 'development' && { 
        debug: results.rawOutput 
      })
    });
    
  } catch (error) {
    const executionTime = Date.now() - startTime;
    console.error(`üí• [SECURITY AUDIT] Error cr√≠tico en ejecuci√≥n - Duraci√≥n: ${executionTime}ms`, error);
    
    // MANEJO ESPECIAL DE ERRORES ENOENT
    if (error.message && error.message.includes('ENOENT')) {
      return res.status(500).json({
        success: false,
        error: 'Comando de sistema no encontrado',
        message: 'El sistema no puede encontrar el comando npx. Verifique la instalaci√≥n de Node.js.',
        details: [
          'Node.js y npm pueden no estar instalados correctamente',
          'Intente reinstalar Node.js desde nodejs.org',
          'En Windows, reinicie la terminal como administrador',
          'Verifique que npm y npx est√©n en el PATH del sistema'
        ],
        executionTime,
        timestamp: new Date().toISOString(),
        errorType: 'ENOENT'
      });
    }
    
    return res.status(500).json({
      success: false,
      error: 'Error interno ejecutando pruebas del sistema',
      message: error.message,
      executionTime,
      timestamp: new Date().toISOString()
    });
  }
}
