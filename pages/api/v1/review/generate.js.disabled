/**
 * ENDPOINT API v1.3 - POST /api/v1/review/generate
 * MISI√ìN 191 - FASE 1: MVP del Sistema de Peer Review Automatizado
 * 
 * Implementa el endpoint principal para el Sistema de Informe de Revisi√≥n por Pares (IRP)
 * automatizado basado en DevDocs.io, seg√∫n ADR-001-DevDocs-IRP-Automatizado.md.
 * 
 * Este endpoint orquesta el proceso RAG completo:
 * 1. RETRIEVE: Obtiene documentaci√≥n oficial desde DevDocs.io
 * 2. AUGMENT: Construye meta-prompt con c√≥digo + contexto + documentaci√≥n
 * 3. GENERATE: Produce IRP en formato Markdown con citas oficiales
 * 
 * Cumple con criterios ADR-001:
 * - 90% de sugerencias incluyen citas a DevDocs.io
 * - Tiempo de respuesta < 30 segundos
 * - Estructura profesional seg√∫n Anexo K
 * - Autenticaci√≥n JWT requerida
 * 
 * @author Mentor Coder
 * @version 1.0.0
 * @fecha 2025-09-26
 * @contrato API v1.3 - NUEVA FUNCIONALIDAD
 */

const { generateIRP } = require('../../../../lib/irp-generator');
const { verifyAuthToken } = require('../../../../lib/auth/verifyAuth');

/**
 * Handler principal del endpoint POST /api/v1/review/generate
 * 
 * @param {Object} req - Request object de Next.js
 * @param {Object} res - Response object de Next.js
 */
export default async function handler(req, res) {
  // Verificar m√©todo HTTP seg√∫n contrato API v1.3
  if (req.method !== 'POST') {
    return res.status(405).json({
      success: false,
      error: 'Method Not Allowed',
      message: 'Este endpoint solo acepta solicitudes POST',
      metadata: {
        apiVersion: '1.3',
        allowedMethods: ['POST'],
        errorCode: 'METHOD_NOT_ALLOWED'
      }
    });
  }

  const startTime = Date.now();
  console.log('[API-v1.3] [IRP] Iniciando solicitud de generaci√≥n de IRP...');

  try {
    // Validar autenticaci√≥n JWT
    const authResult = await validateAuthentication(req);
    if (!authResult.isValid) {
      return res.status(401).json({
        success: false,
        error: 'Unauthorized',
        message: authResult.message,
        metadata: {
          apiVersion: '1.3',
          errorCode: 'AUTH_ERROR'
        }
      });
    }

    console.log(`[API-v1.3] [IRP] Usuario autenticado: ${authResult.userId}`);

    // Validar y extraer datos del cuerpo de la solicitud
    const validationResult = validateRequestBody(req.body);
    if (!validationResult.isValid) {
      return res.status(400).json({
        success: false,
        error: 'Bad Request',
        message: validationResult.message,
        details: validationResult.details,
        metadata: {
          apiVersion: '1.3',
          errorCode: 'VALIDATION_ERROR'
        }
      });
    }

    const { code, context, options } = validationResult.data;
    
    console.log(`[API-v1.3] [IRP] Solicitud v√°lida: ${code.length} chars de c√≥digo, contexto semana ${context.week || 'N/A'}`);

    // Verificar l√≠mites de rate limiting b√°sico
    const rateLimitCheck = checkRateLimit(authResult.userId);
    if (!rateLimitCheck.allowed) {
      return res.status(429).json({
        success: false,
        error: 'Too Many Requests',
        message: 'L√≠mite de solicitudes excedido. Intenta nuevamente en unos minutos.',
        retryAfter: rateLimitCheck.retryAfter,
        metadata: {
          apiVersion: '1.3',
          errorCode: 'RATE_LIMIT_EXCEEDED'
        }
      });
    }

    // Ejecutar proceso RAG para generar IRP
    console.log('[API-v1.3] [IRP] Iniciando proceso RAG...');
    const ragStartTime = Date.now();

    const irpResult = await generateIRP(code, context, {
      ...options,
      userId: authResult.userId
    });

    const ragTime = Date.now() - ragStartTime;
    console.log(`‚úÖ [API-v1.3] [IRP] IRP generado en ${ragTime}ms`);

    // Verificar criterios de calidad ADR-001
    const qualityCheck = validateIRPQuality(irpResult);
    if (!qualityCheck.meetsStandards) {
      console.warn(`‚ö†Ô∏è [API-v1.3] [IRP] IRP no cumple est√°ndares de calidad: ${qualityCheck.issues.join(', ')}`);
    }

    // Construir respuesta seg√∫n contrato API v1.3
    const totalTime = Date.now() - startTime;
    const apiResponse = {
      success: true,
      data: {
        irp: {
          markdownContent: irpResult.markdownContent,
          structure: 'anexo-k',
          generatedAt: irpResult.metadata.generatedAt
        },
        sources: irpResult.sources.map(source => ({
          url: source.url,
          title: source.title,
          technology: source.technology,
          entity: source.entity,
          relevanceScore: calculateRelevanceScore(source, code)
        })),
        quality: {
          citationPercentage: irpResult.statistics.citationPercentage,
          suggestionCount: irpResult.statistics.suggestionCount,
          meetsADRCriteria: irpResult.statistics.meetsADRCriteria,
          structureComplete: irpResult.statistics.structureComplete
        },
        performance: {
          totalTimeMs: totalTime,
          ragTimeMs: ragTime,
          retrieveTimeMs: irpResult.statistics.retrieveTimeMs,
          generateTimeMs: irpResult.statistics.generateTimeMs,
          meetsTimingCriteria: totalTime < 30000 // < 30s seg√∫n ADR-001
        }
      },
      metadata: {
        apiVersion: '1.3',
        userId: authResult.userId,
        requestId: generateRequestId(),
        timestamp: new Date().toISOString(),
        architecture: 'RAG-DevDocs-v1.0',
        llmModel: 'gemini-1.5-pro'
      }
    };

    // Logging de √©xito
    console.log(`üéâ [API-v1.3] [IRP] Solicitud completada exitosamente en ${totalTime}ms`);
    console.log(`üìä [API-v1.3] [IRP] Calidad: ${irpResult.statistics.citationPercentage}% citas, ${irpResult.statistics.suggestionCount} sugerencias`);
    console.log(`‚ö° [API-v1.3] [IRP] Performance: RAG ${ragTime}ms, Total ${totalTime}ms`);

    return res.status(200).json(apiResponse);

  } catch (error) {
    const totalTime = Date.now() - startTime;
    console.error(`‚ùå [API-v1.3] [IRP] Error despu√©s de ${totalTime}ms: ${error.message}`);
    console.error(`‚ùå [API-v1.3] [IRP] Stack trace: ${error.stack}`);

    // Manejo de errores espec√≠ficos
    let statusCode = 500;
    let errorCode = 'INTERNAL_SERVER_ERROR';
    let userMessage = 'Ocurri√≥ un error interno generando el IRP';

    if (error.message.includes('DEVDOCS-RETRIEVER')) {
      statusCode = 503;
      errorCode = 'EXTERNAL_SERVICE_ERROR';
      userMessage = 'Error conectando con DevDocs.io. Intenta nuevamente.';
    } else if (error.message.includes('IRP-GENERATOR')) {
      statusCode = 500;
      errorCode = 'IRP_GENERATION_ERROR';
      userMessage = 'Error generando el IRP. Verifica tu c√≥digo e intenta nuevamente.';
    } else if (error.message.includes('timeout')) {
      statusCode = 504;
      errorCode = 'TIMEOUT_ERROR';
      userMessage = 'La generaci√≥n del IRP tom√≥ demasiado tiempo. Intenta con c√≥digo m√°s simple.';
    }

    return res.status(statusCode).json({
      success: false,
      error: getErrorDescription(statusCode),
      message: userMessage,
      details: process.env.NODE_ENV === 'development' ? error.message : undefined,
      metadata: {
        apiVersion: '1.3',
        errorCode: errorCode,
        processingTimeMs: totalTime,
        timestamp: new Date().toISOString()
      }
    });
  }
}

/**
 * FUNCIONES AUXILIARES DEL ENDPOINT
 */

/**
 * Valida la autenticaci√≥n JWT del usuario
 */
async function validateAuthentication(req) {
  try {
    // Verificar header Authorization
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return {
        isValid: false,
        message: 'Header Authorization con Bearer token es requerido'
      };
    }

    const token = authHeader.substring(7); // Remover 'Bearer '
    
    // TODO: Implementar verificaci√≥n real con Supabase JWT
    // Por ahora, simulaci√≥n b√°sica para MVP
    if (token === 'mock-valid-token') {
      return {
        isValid: true,
        userId: 'mock-user-123',
        email: 'user@example.com'
      };
    }

    // Aqu√≠ ir√≠a la verificaci√≥n real del token
    // const user = await verifyAuthToken(token);
    
    return {
      isValid: false,
      message: 'Token de autenticaci√≥n inv√°lido o expirado'
    };

  } catch (error) {
    console.error('[API-v1.3] [AUTH] Error validando token:', error.message);
    return {
      isValid: false,
      message: 'Error validando autenticaci√≥n'
    };
  }
}

/**
 * Valida el cuerpo de la solicitud seg√∫n contrato API v1.3
 */
function validateRequestBody(body) {
  const errors = [];

  // Validar presencia del cuerpo
  if (!body || typeof body !== 'object') {
    return {
      isValid: false,
      message: 'Cuerpo de la solicitud es requerido',
      details: ['Body must be a valid JSON object']
    };
  }

  // Validar campo 'code' (requerido)
  if (!body.code || typeof body.code !== 'string') {
    errors.push('Campo "code" es requerido y debe ser una cadena');
  } else if (body.code.trim().length === 0) {
    errors.push('Campo "code" no puede estar vac√≠o');
  } else if (body.code.length > 10000) {
    errors.push('Campo "code" excede el l√≠mite de 10,000 caracteres');
  }

  // Validar campo 'context' (requerido)
  if (!body.context || typeof body.context !== 'object') {
    errors.push('Campo "context" es requerido y debe ser un objeto');
  } else {
    // Validar subcampos opcionales de context
    if (body.context.week && (typeof body.context.week !== 'number' || body.context.week < 1 || body.context.week > 100)) {
      errors.push('context.week debe ser un n√∫mero entre 1 y 100');
    }
    if (body.context.topic && (typeof body.context.topic !== 'string' || body.context.topic.length > 200)) {
      errors.push('context.topic debe ser una cadena de m√°ximo 200 caracteres');
    }
  }

  // Validar campo 'options' (opcional)
  if (body.options && typeof body.options !== 'object') {
    errors.push('Campo "options" debe ser un objeto si se proporciona');
  }

  if (errors.length > 0) {
    return {
      isValid: false,
      message: 'Errores de validaci√≥n en la solicitud',
      details: errors
    };
  }

  return {
    isValid: true,
    data: {
      code: body.code.trim(),
      context: {
        week: body.context.week || null,
        topic: body.context.topic || 'C√≥digo sin contexto espec√≠fico',
        phase: body.context.phase || 'General',
        objective: body.context.objective || 'Aplicar buenas pr√°cticas de programaci√≥n'
      },
      options: body.options || {}
    }
  };
}

/**
 * Verificaci√≥n b√°sica de rate limiting (implementaci√≥n simplificada para MVP)
 */
function checkRateLimit(userId) {
  // TODO: Implementar rate limiting real con Redis o base de datos
  // Por ahora, permitir todas las solicitudes para MVP
  return {
    allowed: true,
    remaining: 100,
    retryAfter: null
  };
}

/**
 * Valida la calidad del IRP generado seg√∫n criterios ADR-001
 */
function validateIRPQuality(irpResult) {
  const issues = [];
  let meetsStandards = true;

  // Criterio 1: 90% de sugerencias deben tener citas
  if (irpResult.statistics.citationPercentage < 90) {
    issues.push(`Porcentaje de citas (${irpResult.statistics.citationPercentage}%) por debajo del 90% requerido`);
    meetsStandards = false;
  }

  // Criterio 2: Estructura completa seg√∫n Anexo K
  if (!irpResult.statistics.structureComplete) {
    issues.push('Estructura del IRP incompleta seg√∫n Anexo K');
    meetsStandards = false;
  }

  // Criterio 3: M√≠nimo de sugerencias
  if (irpResult.statistics.suggestionCount < 1) {
    issues.push('IRP debe contener al menos una sugerencia de mejora');
    meetsStandards = false;
  }

  return {
    meetsStandards,
    issues,
    score: irpResult.statistics.citationPercentage
  };
}

/**
 * Calcula score de relevancia de una fuente respecto al c√≥digo
 */
function calculateRelevanceScore(source, code) {
  let score = 0;
  
  // Boost si la entidad aparece en el c√≥digo
  if (code.includes(source.entity)) {
    score += 50;
  }
  
  // Boost por longitud del contenido
  if (source.content && source.content.length > 500) {
    score += 30;
  }
  
  // Boost por tecnolog√≠a relevante
  if (source.technology === 'JavaScript' && /javascript|js|node/.test(code.toLowerCase())) {
    score += 20;
  }
  
  return Math.min(score, 100);
}

/**
 * Genera ID √∫nico para la solicitud
 */
function generateRequestId() {
  return `irp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Obtiene descripci√≥n del error HTTP
 */
function getErrorDescription(statusCode) {
  const descriptions = {
    400: 'Bad Request',
    401: 'Unauthorized',
    403: 'Forbidden',
    404: 'Not Found',
    405: 'Method Not Allowed',
    429: 'Too Many Requests',
    500: 'Internal Server Error',
    503: 'Service Unavailable',
    504: 'Gateway Timeout'
  };
  
  return descriptions[statusCode] || 'Unknown Error';
}
